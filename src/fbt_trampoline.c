/**
 * @file fbt_trampoline.c
 * Implementation of thread local trampolines.
 *
 * Copyright (c) 2011 ETH Zurich
 * @author Mathias Payer <mathias.payer@nebelwelt.net>
 * @author Enrico Kravina <enrico.kravina@gmail.com>
 *
 * $Date: 2012-01-11 11:21:20 +0100 (mer, 11 gen 2012) $
 * $LastChangedDate: 2012-01-11 11:21:20 +0100 (mer, 11 gen 2012) $
 * $LastChangedBy: kravinae $
 * $Revision: 1154 $
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of thce GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA  02110-1301, USA.
 */

#include <stddef.h> /* offsetof */

#include "fbt_trampoline.h"

#include "fbt_asm_macros.h"
#include "fbt_code_cache.h"
#include "fbt_datatypes.h"
#include "fbt_debug.h"
#include "fbt_libc.h"
#include "fbt_llio.h"
#include "fbt_disas.h"
#include "fbt_mem_mgmt.h"
#include "fbt_syscall.h"
#include "fbt_translate.h"

#define PUSH_TRADITIONAL_REGISTES_EXCEPT_RSP \
    push %rax; \
    push %rcx; \
    push %rdx; \
    push %rbx; \
    push %rsi; \
    push %rdi; \
    push %rbp;

#define POP_TRADITIONAL_REGISTES_EXCEPT_RSP \
    pop %rbp; \
    pop %rdi; \
    pop %rsi; \
    pop %rbx; \
    pop %rdx; \
    pop %rcx; \
    pop %rax;

/* ALL BUT NOT %RSP */
#define PUSH_NEW_REGISTES \
    push %r8; \
    push %r9; \
    push %r10; \
    push %r11; \
    push %r12; \
    push %r13; \
    push %r14; \
    push %r15;

#define POP_NEW_REGISTES \
    pop %r15; \
    pop %r14; \
    pop %r13; \
    pop %r12; \
    pop %r11; \
    pop %r10; \
    pop %r9; \
    pop %r8;

static void translate_execute(struct thread_local_data *tld,
    struct trampoline *trampo)
{
  tld->in_bt_context=1
  ENFORCE_ALIGNMENT(tld->transl_instr);

  void *transl_addr = fbt_ccache_find(tld, trampo->target);

  if (transl_addr == NULL) {
    /* so, if the origin of the trampoline is just one void* away from the
       current transl_instr position, then we can just remove the preceding
       1byte jump as we'll continue right here anyway. btw we also must not
       backpatch in that case! */
    if ((uint64_t)trampo->origin ==
        ((uint64_t)tld->transl_instr)-sizeof(void*)) {
      tld->transl_instr = 
          (void*)(((uint64_t)tld->transl_instr) - (sizeof(void*) + 1));
      trampo->origin = NULL;
    }

    transl_addr = fbt_translate_noexecute(tld, trampo->target, TRUE);
  }

  /* use a jump-back trampoline to jump to the translated code in the code
     cache */
  tld->ind_target = transl_addr;

  /* do we need to backpatch the newly translated code (e.g. remove the jump to
     the trampoline and redirect the control flow transfer to the newly
     translated code) */
  if (trampo->origin != NULL) {
    uint32_t *origin = (uint32_t*)(trampo->origin);
    switch (trampo->origin_t) {
    case ORIGIN_CLEAR:
      *origin = 0x0;
      break;
    case ORIGIN_RELATIVE:
      *origin = (uint32_t)((uint64_t)transl_addr - (uint64_t)origin - 4);
      break;
    case ORIGIN_ABSOLUTE:
      assert(0 && "to see if correct");
      *origin = (uint64_t)(transl_addr);
      break;
    default:
      fbt_suicide_str("Illegal origin in trampoline (fbt_trampoline.c).\n");
    }
    /* free trampoline if we were able to backpatch*/
    fbt_trampoline_free(tld, trampo, TRUE);
  }
  tld->in_bt_context=0;
}

/** Generates machine code that performs a cache sweep, after we encounter the
 * 'nohit' case. This allows as to avoid jumping into the libdetox context
 *
 * @section registers Registers
 * in %ebx: target address
 * in %ecx:
 * in %r8d: saved ebx (will be restored on hit)
 * in %r9d: saved ecx (will be restored on hit)
 * Will overwrite %ebx, %ecx
 *
 *
 * @section control-flow Control flow
 * If a cache hit occurs, we redirect control flow to the target instruction
 * If not, the control falls through to the instruction after the code
 * generated by asm_cache_lookup
 *
 * @param  tld Thread-local data
 * @param  transl_instr Address to the memory to which the machine code will
            be written
 * @return One byte after the last byte that was written
 */
static unsigned char *asm_cache_lookup(struct thread_local_data *tld,
    unsigned char *transl_instr,
    BOOL restore_flags)
{
  /* The reason that we use JNE_I8 instead of label support in the DSL, is 
   * this allows us to more easily generate machine code that has modular 
   * components in it, as the DSL needs to know at compile time how long
   * our machine code is.
   */

  BEGIN_ASM(transl_instr)
  /* duplicate target */
  movl %r8d, %r9d

  /* hash table lookup as in C_MAPPING_FUNCTION macro */
  shll $4, %r9d
  andl ${MAPPING_PATTERN}, %r9d

  movabs_to_r10 {tld->mappingtable}

  cmpl (%r10, %r9), %r8d;
  END_ASM

  /* Hit or no hit? jump if ecx is 0 */
  /***********************************/
  JNE_I8(transl_instr, 0x0); /* offset  */
  char *hitloc = ((char*)transl_instr)-1;

  /*  we hit it - lets jump to the correct location */
  /**************************************************/
#ifdef FAST_CACHE_LOOKUP
  uchar *label_hit = (uchar*)(uint64_t)transl_instr;
#endif

  BEGIN_ASM(transl_instr)
  hit:
  /* Load target */
  movq 8(%r10, %r9), %r8
  END_ASM

  if (restore_flags){
    BEGIN_ASM(transl_instr)
    RESTORE_FLAGS_CLOBBERING_R9_R10
    END_ASM
  }

  BEGIN_ASM(transl_instr)
  jmp *%r8
  END_ASM

  /* recover mode - there was no hit! */
  /************************************/
  *hitloc = (char)(((int64_t)transl_instr)-(((int64_t)hitloc)+1));

  BEGIN_ASM(transl_instr)
  nohit:
  // recover mode - there was no hit!
  // ************************************
  END_ASM

#ifdef FAST_CACHE_LOOKUP

  BEGIN_ASM(transl_instr)
  //int3
  END_ASM

  /* A cache hit at this point might be a superficial miss (i.e. there exists
   * an entry, but the queried entry isn't at the first possible location).
   * We therefore scan the code cache to make sure there doesn't already exist
   * an entry, before jumping into the binary translator. */
  unsigned char *label_loop = transl_instr;
  BEGIN_ASM(transl_instr)
  loop:
  cmpl (%r10, %r9), %r8d
  END_ASM

  /* Hash table hit: goto 'hit' label */
  JE_I8(transl_instr,
      (signed char)((int64_t)label_hit - (int64_t)transl_instr - 2));

  BEGIN_ASM(transl_instr)
  cmpl $0, (%r10, %r9)
  END_ASM

  /* We encounter a zero entry: jump to 'nohit_fallback' */
  unsigned char *nohit_fallback_jmp = transl_instr;
  JE_I8(transl_instr, 0x0);

  BEGIN_ASM(transl_instr)
  add $16, %r9
  END_ASM

  JMP_I8(transl_instr,
      (signed char)((int64_t)label_loop - (int64_t)transl_instr - 2));

  /* Backpatch label */
  unsigned char *label_nohit_fallback = transl_instr;
  *(nohit_fallback_jmp + 1) =
      (signed char)((int64_t)label_nohit_fallback -
          (int64_t)nohit_fallback_jmp - 2);
#endif

  return transl_instr;
}

static void initialize_unmanaged_code_trampoline(struct thread_local_data *tld)
{
  ENFORCE_ALIGNMENT(tld->transl_instr);

  unsigned char *transl_instr = tld->transl_instr;
  tld->unmanaged_code_trampoline = (void*)transl_instr;
  PRINT_DEBUG("unmanaged code trampoline is at %p\n", transl_instr);

  /* all trampolines transfer control to this unmanaged code trampoline */

  /* Generate trampoline.
   * The stack looks as follows:
   *   [ esp           ]
   *   [ rip (trampo)  ] <- removed by leal 4(%esp), %esp
   *   [ flags         ]
   *   [ 32b regs      ]
   *   [ trampo        ] <-- removed by leal 8(%esp), %esp
   *   [ tld           ] <-/
   *   [ rip (to here) ]
   * Prerequisites:
   *   movl %esp, (tld->stack-1)
   *   movl tld->stack-1, %esp
   *   call tld->umanaged_code_trampoline
   */
  BEGIN_ASM(transl_instr)

  /* save flags & registers */
  pushf

  PUSH_TRADITIONAL_REGISTES_EXCEPT_RSP

  /* push pointer to thread local data */
  movabs_to_rax {tld}
  movq %rax, %rdi   /* tld as first parameter */

  movq 64(%rsp), %rsi 
  /* return address is used to compute the
     struct trampoline's address which we
     pass as second parameter (which abi says
     should be passed in %rsi) */
  subq $22, %rsi  /* the 21 is the length of the instructions used (see fbt_create_trampoline) */

  PUSH_NEW_REGISTES

  /* needs to figure out and free trampoline */
  call_abs {translate_execute}
  POP_NEW_REGISTES

  /* we need to put it in a register since it is 64 bit
     and something like jmp *{&tld->ind_target} doesn't work directly */
  movabs_to_rax {&tld->ind_target}
  movq (%rax), %r8

  /* restore flags & registers */
  POP_TRADITIONAL_REGISTES_EXCEPT_RSP
  popf

  /* remove rip which was pushed by 'call' */
  lea 8(%rsp), %rsp

  /* restore esp to original stack frame */
  popq %rsp
  jmp *%r8

  END_ASM

  /* forward pointer */
  tld->transl_instr = transl_instr;
}

static void mywatchpointhandler(struct thread_local_data *tld)
{
  llprintf("mywatchpointhandler:\n");
  llprintf("%eip = %x\n", tld->wp_saved_pc);
  llprintf("%eax = %x\n", tld->wp_saved_eax);
  llprintf("%ebx = %x\n", tld->wp_saved_ebx);
  llprintf("%ecx = %x\n", tld->wp_saved_ecx);
  llprintf("%edx = %x\n", tld->wp_saved_edx);
  llprintf("%esi = %x\n", tld->wp_saved_esi);
  llprintf("%edi = %x\n", tld->wp_saved_edi);
  llprintf("%ebp = %x\n", tld->wp_saved_ebp);
  llprintf("%esp = %x\n", tld->wp_saved_esp);
  llprintf("Will continue at...\n");
  print64(1, tld->wp_saved_next_trans_instr);
}

static void initialize_watchpoint_trampoline(struct thread_local_data *tld) 
{
  ENFORCE_ALIGNMENT(tld->transl_instr);

  unsigned char *transl_instr = tld->transl_instr;
  tld->watchpoint_trampoline = (void*)transl_instr;
  PRINT_DEBUG("watchpoint code trampoline is at %p\n", transl_instr);

  BEGIN_ASM(transl_instr)
    /* THE CALLER MUST PUT THE IP INTO R9 */

    /* save the program state when the watchpoint was hit.
       this info can be useful for the watchpoint handler
       e.g. to inform the user about the state of registers */
    movabs_to_r8 {&tld->wp_saved_pc}
    mov %r9d, (%r8)
    movabs_to_r8 {&tld->wp_saved_eax}
    mov %eax, (%r8)
    movabs_to_r8 {&tld->wp_saved_ebx}
    mov %ebx, (%r8)
    movabs_to_r8 {&tld->wp_saved_ecx}
    mov %ecx, (%r8)
    movabs_to_r8 {&tld->wp_saved_edx}
    mov %edx, (%r8)
    movabs_to_r8 {&tld->wp_saved_esi}
    mov %esi, (%r8)
    movabs_to_r8 {&tld->wp_saved_edi}
    mov %edi, (%r8)
    movabs_to_r8 {&tld->wp_saved_ebp}
    mov %ebp, (%r8)
    movabs_to_r8 {&tld->wp_saved_esp}
    mov %esp, (%r8)
    movabs_to_r8 {&tld->wp_saved_arflagsreg}
    
    /* Switch to secured stack */
    movabs_to_r8 {tld->stack}
    movq %r8, %rsp   /* switch stack */

    PUSH_NEW_REGISTES

    pushf

    movabs_to_r8 {tld}
    mov %r8, %rdi /* amd64 calling convention first parameter */
    movabs_to_r8 {&mywatchpointhandler}
    call *%r8

    popf

    POP_NEW_REGISTES

    /* restore the program state  */
    movabs_to_r8 {&tld->wp_saved_pc}
    mov (%r8), %r9d
    movabs_to_r8 {&tld->wp_saved_eax}
    mov (%r8), %eax
    movabs_to_r8 {&tld->wp_saved_ebx}
    mov (%r8), %ebx
    movabs_to_r8 {&tld->wp_saved_ecx}
    mov (%r8), %ecx
    movabs_to_r8 {&tld->wp_saved_edx}
    mov (%r8), %edx
    movabs_to_r8 {&tld->wp_saved_esi}
    mov (%r8), %esi
    movabs_to_r8 {&tld->wp_saved_edi}
    mov (%r8), %edi
    movabs_to_r8 {&tld->wp_saved_ebp}
    mov (%r8), %ebp
    movabs_to_r8 {&tld->wp_saved_esp}
    mov (%r8), %esp

    int3; /* in practice this line should be commented out */

    movabs_to_r8 {&tld->wp_saved_next_trans_instr}
    mov (%r8), %r8
    jmp *%r8

  END_ASM

  /* forward pointer */
  tld->transl_instr = transl_instr;
}

static void* create_indirect_jump_trampoline(struct thread_local_data *tld,
    BOOL restore_flags)
{
  ENFORCE_ALIGNMENT(tld->transl_instr);

  unsigned char *transl_instr = tld->transl_instr;
  void* result = (void*)transl_instr;
  PRINT_DEBUG("indirect jump trampoline is at %p\n", transl_instr);

  transl_instr = asm_cache_lookup(tld, transl_instr, restore_flags);

  BEGIN_ASM(transl_instr)

  movq %r8, %r11

  movq %rax, %r10   /* save eax */
  movl %ebx, %r8d   /* save ebx */
  movl %ecx, %r9d   /* save ecx */

  /* save the target on the top of the secure stack. */
  movabs_to_rax {tld->stack-1}
  movl %r11d, (%rax)

  /* Switch to secured stack */
  movabs_to_rax {tld->stack-2}
  movq %rsp, (%rax) /* save old rsp on the secure stack */
  movq %rax, %rsp   /* switch stack */

  PUSH_TRADITIONAL_REGISTES_EXCEPT_RSP

  /* Call translate_noexecute */
  movabs_to_rax {tld}
  movq %rax, %rdi     /* tld is the first parameter */
  movl %r11d, %esi    /* target is the second parameter */
  movl $1, %edx       /* lock is the third parameter */

  PUSH_NEW_REGISTES
  call_abs {&fbt_translate_noexecute}
  POP_NEW_REGISTES

  /* save result (that is, the 64 bit ptr pointing to the translated code)
     into tld->ind_target */
  pushq %r8
  movq %rax, %r8
  movabs_to_rax {&tld->ind_target}
  movq %r8, (%rax)
  popq %r8

  POP_TRADITIONAL_REGISTES_EXCEPT_RSP

  /* restore esp (switch back to application stack) */
  popq %rsp

  /* restore the eax, ebx, ecx registers to their application values */
  movl %r8d, %ebx
  movl %r9d, %ecx
  movq %r10, %rax

  /* prepare for indirect jmp */
  movabs_to_r8 {&tld->ind_target}
  END_ASM

  if (restore_flags){
    BEGIN_ASM(transl_instr)
    RESTORE_FLAGS_CLOBBERING_R9_R10
    END_ASM
  }

  BEGIN_ASM(transl_instr)
  jmp *(%r8)
  END_ASM

  /* forward pointer */
  tld->transl_instr = transl_instr;

  return result;
}

static void initialize_int80_trampoline(struct thread_local_data *tld) 
{
  ENFORCE_ALIGNMENT(tld->transl_instr);

  unsigned char *transl_instr = tld->transl_instr;
  tld->int80_trampoline = (void*)transl_instr;
  PRINT_DEBUG("int80 trampoline is at %p\n", transl_instr);

  BEGIN_ASM(transl_instr)

  /* Switch to secured stack */
  movabs_to_r8 {tld->stack-1}
  movq %rsp, (%r8) // save old rsp on the secure stack
  movq %rsp, %r9   // also put it in %r9
  movq %r8, %rsp   // switch stack

  /* Save all the registers (to be on the safe side) */
  PUSH_TRADITIONAL_REGISTES_EXCEPT_RSP

  /* to support clone() we like to store them explicitly */
  movabs_to_r8 {&tld->thread_saved_eax}
  mov %eax, (%r8)
  movabs_to_r8 {&tld->thread_saved_ebx}
  mov %ebx, (%r8)
  movabs_to_r8 {&tld->thread_saved_ecx}
  mov %ecx, (%r8)
  movabs_to_r8 {&tld->thread_saved_edx}
  mov %edx, (%r8)
  movabs_to_r8 {&tld->thread_saved_esi}
  mov %esi, (%r8)
  movabs_to_r8 {&tld->thread_saved_edi}
  mov %edi, (%r8)
  movabs_to_r8 {&tld->thread_saved_ebp}
  mov %ebp, (%r8)

  pushq $-1        /* space for return value of the syscall
                      which is returned by pointer */
  pushq %rsp       /* param 10 (pointer to return value) */
  pushq $0x0       /* param 9 (issysenter ... always false) */

  movl  %ebp,%r10d
  pushq %r10       /* param 8 (syscall_arg_6) */

  movl  %edi,%r10d
  pushq %r10       /* param 7 (syscall_arg_5) */

  movl  %esi, %r9d /* param 6 (syscall_arg_4) */

  movl  %edx,%r8d  /* param 5 (syscall_arg_3) */

  movl %ecx,%ecx   /* param 4 (syscall_arg_2) */

  movl  %ebx,%edx  /* param 3 (syscall_arg_1) */

  movl %eax,%esi   /* param 2 (syscall_nr) */


  pushq %rax           /* ok, have to work around to write the tld in it */
  movabs_to_rax {tld}
  mov %rax,%rdi        /* param 1 (tld) */
  popq %rax

  call_in_table:

  /* Ensure that eax is in range */
  andl ${MAX_SYSCALLS_TABLE-1}, %eax

  /* Call the function in the syscall table
     corresponding to the syscall number */
  push %r8
  movabs_to_r8 {tld->syscall_table}
  mov %r8, %r10
  pop %r8
  call *(%r10,%rax,8)

  /* Remove parameters that were passed by stack */
  lea 32(%rsp), %rsp

  /* Pop the result that was passed by pointer into r8 */
  pop %r8

  cmpl ${(char)SYSCALL_AUTH_GRANTED}, %eax
  je auth_granted

  POP_TRADITIONAL_REGISTES_EXCEPT_RSP

  /* Put (fake) result into %eax */
  mov %r8, %rax

  /* Restore original stack */
  popq %rsp

  movabs_to_r8 {&tld->ind_target}

  jmp *(%r8)

  int3 /* never reached */

  auth_granted:

  POP_TRADITIONAL_REGISTES_EXCEPT_RSP

  /* Restore original stack */
  popq %rsp

  /* Call the real syscall */
  int $0x80

  movabs_to_r8 {&tld->ind_target}

  jmp *(%r8)

  END_ASM

  /* forward pointer */
  tld->transl_instr = transl_instr;
}

/**
 * The main function of this module
 */
void fbt_initialize_trampolines(struct thread_local_data *tld) 
{
  initialize_unmanaged_code_trampoline(tld);
  tld->opt_ijump_trampoline = create_indirect_jump_trampoline(tld, TRUE);
  tld->opt_icall_trampoline = create_indirect_jump_trampoline(tld,
      !LMEM_DO_NOT_PRESERVE_EFLAGS_OVER_CALL_INDIRECT);
  tld->opt_ret_trampoline = create_indirect_jump_trampoline(tld,
      !LMEM_DO_NOT_PRESERVE_EFLAGS_OVER_RET);
  initialize_watchpoint_trampoline(tld);
  initialize_int80_trampoline(tld);
}
